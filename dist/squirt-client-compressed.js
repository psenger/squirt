#!/usr/bin/env node
"use strict";var e=require("zlib"),t=require("fs"),r=require("crypto"),s=require("readline"),n=require("child_process"),o=require("os"),i=require("stream"),a=require("path"),c=require("http"),p={};const l=r;p.encryptValue=(e,t,r,s=null,n="aes-256-ecb")=>{const o=l.scryptSync(t,r,32),i=l.createCipheriv(n,o,s,{});let a=i.update(e,"utf8","hex");return a+=i.final("hex"),a},p.decryptValue=(e,t,r,s=null,n="aes-256-ecb")=>{const o=l.scryptSync(t,r,32),i=l.createDecipheriv(n,o,s,{});let a=i.update(e,"hex","utf8");return a+=i.final("utf8"),a},p.genKey=(e,t,r=32)=>l.scryptSync(e,t,r);var u={};const y=s,{spawnSync:d}=n,m=t,f=o,{Transform:g}=i;u.prompt=async e=>{const t={};function r(e){return new Promise((async r=>{const{type:s,name:n,message:o,validate:i,filter:a,def:c}=e;async function p(e){if(i){const t=await i(e);if(!0!==t)return console.log(t),!1}return!0}function l(e){return a?a(e):e}!function e(){if("editor"===s)new Promise((e=>{const t=y.createInterface({input:process.stdin,output:process.stdout});t.question(`${o}`,(()=>{t.close(),e()}))})).then((async()=>{const s=`${m.mkdtempSync(`${f.tmpdir()}/`)}/${n}.tmp`,o=process.env.EDITOR||"vi";d(o,[s],{stdio:"inherit"});const i=m.readFileSync(s,"utf8");await p(i)?(t[n]=l(i),r(),m.unlinkSync(s)):e()}));else if("input"===s){const s=y.createInterface({input:process.stdin,output:process.stdout}),i=""+(c?` (${c}) `:" ");s.question(`${o}${i}:`,(async o=>{0===o.trim().length&&c&&(o=c);await p(o)?(t[n]=l(o),s.close(),r()):(s.close(),e())}))}else if("confirm"===s){const e=y.createInterface({input:process.stdin,output:process.stdout}),s=`${c?"(y)":"y"}/${c?"n":"(n)"}`;e.question(`${o} ${s}: `,(s=>{t[n]=!!(s||""+(c?"y":"n")).match(/^y(es)?$/i),e.close(),r()}))}else if("password"===s){const s=process.stdin,i=process.stdout;s.setRawMode(!0),s.resume(),i.write(`${o}: `);let a="";s.pipe(new g({encoding:"utf8",transform(e,t,r){const s="*".repeat(e.length);this.push(s),r()}})).pipe(i);const c=async o=>{if("\r"===o.toString()||"\n"===o.toString()){s.pause(),i.write("\n"),s.setRawMode(!1),s.removeListener("data",c);await p(a)?(t[n]=l(a),s.unpipe(),i.unpipe(),r()):(s.unpipe(),i.unpipe(),e())}else a+=o.toString()};s.on("data",c)}}()}))}return async function(){for(const t of e)await r(t);return t}()};var h={exports:{}};!function(e){const{join:r,normalize:s,dirname:n}=a,{readdirSync:o,statSync:i,lstatSync:c,mkdirSync:p,existsSync:l}=t,u=a,y=e=>(...t)=>!e(...t);e.exports.ifExist=e=>l(e),e.exports.ifNotExist=y(e.exports.ifExist),e.exports.isDirectory=e=>!!l(e)&&i(e).isDirectory(),e.exports.isNotDirectory=y(e.exports.isDirectory),e.exports.isFile=e=>!!l(e)&&i(e).isFile(),e.exports.isNotFile=y(e.exports.isFile),e.exports.buildStat=(t,s)=>{const n=i(r(t,s)),o=c(r(t,s));let a=e.exports.filePermissions(n),p=n.isFile();return{filePath:s,isDir:n.isDirectory(),isFile:p,isSymLink:o.isSymbolicLink(),perms:a,bytes:n.size,createdTime:n.birthtime,modifiedTime:n.mtime}},e.exports.ensurePathExists=function(t){try{const r=n(s(t));if(l(r))return;e.exports.ensurePathExists(r),p(r)}catch(e){}},e.exports.walkDirGen=async function*t(s,n){const i=o(u.join(s,n));for(const o of i){const{isDir:i,isFile:a,isSymLink:c,perms:p,bytes:l}=e.exports.buildStat(r(s,n),o);a?yield{filePath:u.join(n,o),isDir:i,isFile:a,perms:p,bytes:l}:i&&!c&&(yield*t(s,u.join(n,o)))}},e.exports.mkDirRecursivelySync=function(e){p(e,{recursive:!0})}}(h);var S=h.exports,x={};const b=e=>e.replace(/\//g,"\\/"),w=e=>e.replace(/\./g,"\\."),v=e=>e.replace(/\*{2}/g,".*"),R=e=>e.replace(/\?/g,".{1}"),$=e=>e.replace(/(?<!\*)\*(?!\*)/g,"[^\\/]*"),E=e=>e.replace(/\{(.*)\}/g,"($1)"),T=e=>e.replace(/\[!(.*)\]/g,"[^($1)]");x.globToRegex=e=>`^${[E,w,b,$,v,R,T].reduce(((e,t)=>t(e)),e)}$`;const P=e,D=t,k=r,{encryptValue:I,genKey:q}=p,{prompt:G}=u,{buildStat:L,walkDirGen:U,isNotDirectory:B,ifNotExist:C}=S,{globToRegex:A}=x,F=c,{join:N,normalize:O,sep:M}=a;["SIGHUP","SIGINT","SIGQUIT","SIGABRT","SIGTERM","SIGUSR2"].forEach((function(e){process.on(e,(function(){process.exit(0)}))}));(async()=>{const[,,...e]=process.argv;if(1===e.length&&"--headless"===e[0])return console.log("Running in headless mode"),{serverUrl:process.env.SERVERURL,passphrase:process.env.PASSPHRASE,salt:process.env.SALT,directory:process.env.DIRECTORY,globPatterns:[new RegExp(A("**"))],dryRun:!1,MaxWorkers:4,encryptionAlgorithm:process.env.ENCRYPTIONALGORITHM};const{serverUrl:t,passphrase:r,salt:s,directory:n,includeGlob:o,dryRun:i}=await G([{type:"input",name:"serverUrl",message:"Enter the server URL",validate:async e=>!!/^(http:\/\/)?([a-zA-Z0-9.-]+)(:[0-9]+)?\/$/.test(e)||"Try again, the URL was not valid"},{type:"password",name:"passphrase",message:"Enter a Passphrase",validate:async e=>Buffer.byteLength(e,"utf8")>32||`Try again, the passphrase was only ${Buffer.byteLength(e,"utf8")} bytes and needs to be 32 Bytes`},{type:"password",name:"salt",message:"Enter a Salt",validate:async e=>Buffer.byteLength(e,"utf8")>16||`Try again, the salt was only ${Buffer.byteLength(e,"utf8")} bytes and needs to be 16 Bytes`},{type:"confirm",name:"dryRun",message:"Execute a dry run only",def:!0},{type:"input",name:"directory",message:"Enter a directory",validate:async e=>C(e)?"Try again, the Directory does not exist.":!B(e)||`Try again, ${e} does not appear to be a Directory.`,filter:e=>O(e).endsWith(M)?e:O(N(e,M))},{type:"confirm",name:"includeGlob",message:"Include Globs",def:!1}]),a=[];if(o){const e=await G([{type:"editor",name:"globPatterns",message:"You are about to enter your OS default editor. Enter a glob pattern, one per line, save the file, and exit to continue. Hit enter to start.",validate:async e=>e.length>0||"Try again, the glob pattern was empty",filter:e=>e.split("\n").filter(Boolean).map((e=>e.trim()))}]);a.push(...e.globPatterns.map(A).map((e=>new RegExp(e))))}else a.push(new RegExp(A("**")));return{serverUrl:t,passphrase:r,salt:s,directory:n,globPatterns:a,dryRun:i,MaxWorkers:4,encryptionAlgorithm:"aes-256-cbc"}})().then((async({serverUrl:e,passphrase:t,salt:r,directory:s,globPatterns:n,dryRun:o,MaxWorkers:i,encryptionAlgorithm:a})=>{console.log(`Starting client connecting to ${e}`);const c=q(t,r),p=k.randomBytes(16),l=e=>n.some((t=>t.test(e))),u=[];for await(let{filePath:n,perms:y}of U(s,"."))l(n)?o?console.log(n):y.o.r&&y.g.r&&y.u.r?(u.push(new Promise((async(o,i)=>{console.log(`Sending ${n}`);const l={[k.randomBytes(16).toString("hex")]:k.randomBytes(16).toString("hex")},u=I(JSON.stringify({...l,...L(s,n),iv:p.toString("hex")}),t,r),y=async function({hostname:e,port:t,pathname:r}){return y.timeout?y.timeout*=1.66:y.timeout=500,new Promise(((s,n)=>{const o=F.request({hostname:e,port:t,path:r,method:"GET"},(o=>{302===o.statusCode&&o.headers.location?(delete y.timeout,s(o.headers.location)):503===o.statusCode?setTimeout((()=>{s(y({hostname:e,port:t,pathname:r}))}),y.timeout):n(new Error(`Unable to get worker, status code ${o.statusCode}`))}));o.on("error",(e=>{console.error(`problem with request: ${e.message}`),n(new Error(`Unable to get worker, error message ${e.message}`))})),o.end()}))},d=await y(new URL(e)),m={method:"POST",headers:{"Content-Type":"application/octet-stream",meta:u}},f=F.request(d,m,(e=>{let t=e.statusCode,r="";e.on("data",(e=>{r+=e})),e.on("end",(()=>{o({body:r,statusCode:t})}))}));f.on("error",i),D.createReadStream(O(N(s,n))).pipe(k.createCipheriv(a,c,p,{})).pipe(P.createGzip()).pipe(f)}))),u.length>=i&&(await Promise.all(u),u.length=0)):console.log(`Skipping ${n}, insufficient permissions to read the file`):console.log(`Skipping ${n}, did not match any GLOBs`)})).catch((e=>{console.error("Error:",e),process.exit(1)})),module.exports={};
